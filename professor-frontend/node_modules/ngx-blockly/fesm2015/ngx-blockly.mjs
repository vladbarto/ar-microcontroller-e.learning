import * as Blockly from 'blockly/core';
export { Blockly };
import * as EN from 'blockly/msg/en';
import * as i0 from '@angular/core';
import { EventEmitter, Component, Input, Output, ViewChild, HostListener, NgModule, NO_ERRORS_SCHEMA } from '@angular/core';
import { dartGenerator } from 'blockly/dart';
import { luaGenerator } from 'blockly/lua';
import { javascriptGenerator } from 'blockly/javascript';
import { phpGenerator } from 'blockly/php';
import { pythonGenerator } from 'blockly/python';
import { UUID } from 'angular2-uuid';

var NgxBlocklyGenerator;
(function (NgxBlocklyGenerator) {
    NgxBlocklyGenerator["DART"] = "Dart";
    NgxBlocklyGenerator["JAVASCRIPT"] = "JavaScript";
    NgxBlocklyGenerator["LUA"] = "Lua";
    NgxBlocklyGenerator["PHP"] = "PHP";
    NgxBlocklyGenerator["PYTHON"] = "Python";
    NgxBlocklyGenerator["XML"] = "Xml";
})(NgxBlocklyGenerator || (NgxBlocklyGenerator = {}));

class NgxBlocklyComponent {
    constructor() {
        this.config = {};
        this.customBlocks = [];
        this.readOnly = false;
        this.workspaceCreate = new EventEmitter();
        this.workspaceChange = new EventEmitter();
        this.toolboxChange = new EventEmitter();
        this.dartCode = new EventEmitter();
        this.javascriptCode = new EventEmitter();
        this.luaCode = new EventEmitter();
        this.phpCode = new EventEmitter();
        this.pythonCode = new EventEmitter();
        this.xmlCode = new EventEmitter();
        this._finishedLoading = false;
    }
    static initCustomBlocks(blocks) {
        if (blocks) {
            for (const customBlock of blocks) {
                Blockly.Blocks[customBlock.type] = {
                    init: function () {
                        const block = new customBlock.class(customBlock.type, customBlock.blockMutator, ...customBlock.args);
                        block.init(this);
                        this.mixin({
                            blockInstance: block
                        });
                    }
                };
                pythonGenerator[customBlock.type] = function (b) {
                    return b.blockInstance.toPythonCode(b);
                };
                dartGenerator[customBlock.type] = function (b) {
                    return b.blockInstance.toDartCode(b);
                };
                javascriptGenerator[customBlock.type] = function (b) {
                    return b.blockInstance.toJavaScriptCode(b);
                };
                luaGenerator[customBlock.type] = function (b) {
                    return b.blockInstance.toLuaCode(b);
                };
                phpGenerator[customBlock.type] = function (b) {
                    return b.blockInstance.toPHPCode(b);
                };
                if (customBlock.blockMutator) {
                    const mutator_mixin = {
                        mutationToDom: function () {
                            return customBlock.blockMutator.mutationToDom.call(customBlock.blockMutator, this);
                        },
                        domToMutation: function (xmlElement) {
                            customBlock.blockMutator.domToMutation.call(customBlock.blockMutator, this, xmlElement);
                        },
                        saveExtraState: function () {
                            return customBlock.blockMutator.saveExtraState.call(customBlock.blockMutator);
                        },
                        loadExtraState: function (state) {
                            customBlock.blockMutator.loadExtraState.call(customBlock.blockMutator, state);
                        }
                    };
                    if (customBlock.blockMutator.blockList && customBlock.blockMutator.blockList.length > 0) {
                        mutator_mixin.decompose = function (workspace) {
                            return customBlock.blockMutator.decompose.call(customBlock.blockMutator, this, workspace);
                        };
                        mutator_mixin.compose = function (topBlock) {
                            customBlock.blockMutator.compose.call(customBlock.blockMutator, this, topBlock);
                        };
                        mutator_mixin.saveConnections = function (containerBlock) {
                            customBlock.blockMutator.saveConnections.call(customBlock.blockMutator, this, containerBlock);
                        };
                    }
                    Blockly.Extensions.unregister(customBlock.blockMutator.name);
                    Blockly.Extensions.registerMutator(customBlock.blockMutator.name, mutator_mixin, function () {
                        customBlock.blockMutator.afterBlockInit.call(customBlock.blockMutator, this);
                    }, customBlock.blockMutator.blockList);
                }
            }
        }
    }
    ngOnInit() {
        NgxBlocklyComponent.initCustomBlocks(this.customBlocks);
    }
    ngAfterViewInit() {
        const readOnly = this.config.readOnly || this.readOnly;
        this.config.readOnly = false;
        this.workspace = Blockly.inject(this.primaryContainer.nativeElement, this.config);
        this.workspace.addChangeListener(this._onWorkspaceChange.bind(this));
        this.workspace.fireChangeListener(new Blockly.Events.FinishedLoading());
        this.workspaceCreate.emit(this.workspace);
        this.resize();
        if (readOnly) {
            this.setReadonly(true);
            this.config.readOnly = true;
        }
    }
    ngOnChanges(changes) {
        // skip this if the change comes before we are initialized
        if (changes.readOnly && this._secondaryWorkspace) {
            this.setReadonly(changes.readOnly.currentValue);
        }
    }
    ngOnDestroy() {
        if (this.workspace) {
            this.workspace.dispose();
        }
        if (this._secondaryWorkspace) {
            this._secondaryWorkspace.dispose();
        }
    }
    onResize(event) {
        clearTimeout(this._resizeTimeout);
        this._resizeTimeout = setTimeout(() => this.resize(), 200);
    }
    /**
     * Generate code for all blocks in the workspace to the specified output.
     * @param workspaceId Workspace to generate code from.
     */
    workspaceToCode(workspaceId) {
        for (const generator of this.config.generators) {
            switch (generator) {
                case NgxBlocklyGenerator.DART:
                    this.dartCode.emit(dartGenerator.workspaceToCode(Blockly.Workspace.getById(workspaceId)));
                    break;
                case NgxBlocklyGenerator.LUA:
                    this.luaCode.emit(luaGenerator.workspaceToCode(Blockly.Workspace.getById(workspaceId)));
                    break;
                case NgxBlocklyGenerator.JAVASCRIPT:
                    this.javascriptCode.emit(javascriptGenerator.workspaceToCode(Blockly.Workspace.getById(workspaceId)));
                    break;
                case NgxBlocklyGenerator.PHP:
                    this.phpCode.emit(phpGenerator.workspaceToCode(Blockly.Workspace.getById(workspaceId)));
                    break;
                case NgxBlocklyGenerator.PYTHON:
                    this.pythonCode.emit(pythonGenerator.workspaceToCode(Blockly.Workspace.getById(workspaceId)));
                    break;
                case NgxBlocklyGenerator.XML:
                    this.xmlCode.emit(Blockly.Xml.domToPrettyText(Blockly.Xml.workspaceToDom(Blockly.Workspace.getById(workspaceId))));
                    break;
            }
        }
    }
    /**
     * Converts a DOM structure into properly indented text.
     * @return Text representation.
     */
    toXml() {
        return Blockly.Xml.domToPrettyText(Blockly.Xml.workspaceToDom(this.workspace));
    }
    /**
     * Clear the given workspace then decode an XML DOM and
     * create blocks on the workspace.
     * @param xml XML DOM..
     */
    fromXml(xml) {
        this._finishedLoading = false;
        Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.Xml.textToDom(xml), this.workspace);
        if (this._secondaryWorkspace) {
            Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.Xml.textToDom(xml), this._secondaryWorkspace);
        }
    }
    /**
     * Decode an XML DOM and create blocks on the workspace. Position the new
     * blocks immediately below prior blocks, aligned by their starting edge.
     * @param xml The XML DOM.
     */
    appendFromXml(xml) {
        Blockly.Xml.appendDomToWorkspace(Blockly.Xml.textToDom(xml), this.workspace);
        if (this._secondaryWorkspace) {
            Blockly.Xml.appendDomToWorkspace(Blockly.Xml.textToDom(xml), this._secondaryWorkspace);
        }
    }
    /**
     * Dispose of all blocks in workspace, with an optimization to prevent resizes.
     */
    clear() {
        if (this.workspace) {
            this.workspace.clear();
        }
    }
    /**
     * Clear the undo/redo stacks.
     */
    clearUndo() {
        if (this.workspace) {
            this.workspace.clearUndo();
        }
    }
    /**
     * Clear the reference to the current gesture.
     */
    clearGesture() {
        if (this.workspace) {
            this.workspace.clearGesture();
        }
    }
    /**
     * Clear search input and result set.
     */
    clearSearch() {
        if (this.workspace) {
            const toolbox = this.workspace.getToolbox();
            if (toolbox && typeof toolbox.clearSearch === 'function') {
                toolbox.clearSearch();
            }
        }
    }
    /**
     * Size the workspace when the contents change. This also updates
     * scrollbars accordingly.
     */
    resize() {
        if (this.workspace) {
            Blockly.svgResize(this.workspace);
        }
        if (this._secondaryWorkspace) {
            Blockly.svgResize(this._secondaryWorkspace);
        }
    }
    setReadonly(readOnly) {
        this.readOnly = readOnly;
        if (readOnly) {
            this.secondaryContainer.nativeElement.classList.remove('hidden');
            if (!this._secondaryWorkspace) {
                const config = Object.assign({}, this.config);
                config.readOnly = true;
                this._secondaryWorkspace = Blockly.inject(this.secondaryContainer.nativeElement, config);
            }
            Blockly.Xml.clearWorkspaceAndLoadFromXml(Blockly.Xml.textToDom(this.toXml()), this._secondaryWorkspace);
            Blockly.svgResize(this._secondaryWorkspace);
        }
        else {
            if (this._secondaryWorkspace) {
                this.secondaryContainer.nativeElement.classList.add('hidden');
            }
        }
    }
    highlightBlock(blockId) {
        if (this.workspace) {
            this.workspace.highlightBlock(blockId);
        }
        if (this._secondaryWorkspace) {
            this._secondaryWorkspace.highlightBlock(blockId);
        }
    }
    _onWorkspaceChange(event) {
        this.workspaceChange.emit(event);
        if (event.type === Blockly.Events.FINISHED_LOADING) {
            this._finishedLoading = true;
        }
        if (this._finishedLoading) {
            if (event instanceof Blockly.Events.BlockBase ||
                event instanceof Blockly.Events.VarBase ||
                event instanceof Blockly.Events.CommentBase) {
                this.workspaceToCode(event.workspaceId);
            }
            if (event.type === Blockly.Events.TOOLBOX_ITEM_SELECT) {
                this.toolboxChange.emit(event);
            }
        }
    }
}
NgxBlocklyComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NgxBlocklyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
NgxBlocklyComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.12", type: NgxBlocklyComponent, selector: "ngx-blockly", inputs: { config: "config", customBlocks: "customBlocks", readOnly: "readOnly" }, outputs: { workspaceCreate: "workspaceCreate", workspaceChange: "workspaceChange", toolboxChange: "toolboxChange", dartCode: "dartCode", javascriptCode: "javascriptCode", luaCode: "luaCode", phpCode: "phpCode", pythonCode: "pythonCode", xmlCode: "xmlCode" }, host: { listeners: { "window:resize": "onResize($event)" } }, viewQueries: [{ propertyName: "primaryContainer", first: true, predicate: ["primaryContainer"], descendants: true }, { propertyName: "secondaryContainer", first: true, predicate: ["secondaryContainer"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<div id=\"blockly-wrapper\" class=\"blockly-wrapper\">\n    <div #primaryContainer class=\"blockly\"></div>\n    <div #secondaryContainer class=\"blockly hidden\"></div>\n</div>\n", styles: [".blockly-wrapper{width:100%;height:100%}.blockly{position:absolute;width:100%;min-width:100%;height:100%;min-height:100%}.blockly{z-index:1}.blockly.hidden{display:none;z-index:0}::ng-deep .blockly .blocklyToolboxDiv{display:flex;flex-direction:column;justify-content:flex-start;overflow:auto}::ng-deep .blockly .blocklyToolboxDiv .blocklyTreeRoot{overflow-x:visible;overflow-y:auto;flex:1}::ng-deep .blockly .blocklyToolboxDiv input.searchbar{border:none;background-color:transparent;font-size:16px;padding:8px 25px 4px;border-bottom:1px solid #ccc;background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6Ii8+PC9zdmc+) no-repeat right center;min-width:120px}::ng-deep .blockly .blocklyToolboxDiv input.searchbar:focus{outline:none}\n"] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NgxBlocklyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-blockly', template: "<div id=\"blockly-wrapper\" class=\"blockly-wrapper\">\n    <div #primaryContainer class=\"blockly\"></div>\n    <div #secondaryContainer class=\"blockly hidden\"></div>\n</div>\n", styles: [".blockly-wrapper{width:100%;height:100%}.blockly{position:absolute;width:100%;min-width:100%;height:100%;min-height:100%}.blockly{z-index:1}.blockly.hidden{display:none;z-index:0}::ng-deep .blockly .blocklyToolboxDiv{display:flex;flex-direction:column;justify-content:flex-start;overflow:auto}::ng-deep .blockly .blocklyToolboxDiv .blocklyTreeRoot{overflow-x:visible;overflow-y:auto;flex:1}::ng-deep .blockly .blocklyToolboxDiv input.searchbar{border:none;background-color:transparent;font-size:16px;padding:8px 25px 4px;border-bottom:1px solid #ccc;background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6Ii8+PC9zdmc+) no-repeat right center;min-width:120px}::ng-deep .blockly .blocklyToolboxDiv input.searchbar:focus{outline:none}\n"] }]
        }], propDecorators: { config: [{
                type: Input
            }], customBlocks: [{
                type: Input
            }], readOnly: [{
                type: Input
            }], workspaceCreate: [{
                type: Output
            }], workspaceChange: [{
                type: Output
            }], toolboxChange: [{
                type: Output
            }], dartCode: [{
                type: Output
            }], javascriptCode: [{
                type: Output
            }], luaCode: [{
                type: Output
            }], phpCode: [{
                type: Output
            }], pythonCode: [{
                type: Output
            }], xmlCode: [{
                type: Output
            }], primaryContainer: [{
                type: ViewChild,
                args: ['primaryContainer']
            }], secondaryContainer: [{
                type: ViewChild,
                args: ['secondaryContainer']
            }], onResize: [{
                type: HostListener,
                args: ['window:resize', ['$event']]
            }] } });

class NgxBlocklyGeneratorConfig {
}

class Block {
    constructor(type) {
        this.kind = 'BLOCK';
        this._disabled = false;
        this._type = type;
    }
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
    }
    get class() {
        return this._class;
    }
    set class(value) {
        this._class = value;
    }
}

class CustomBlock extends Block {
    constructor(type, blockMutator, ...args) {
        super(type);
        this._blockMutator = blockMutator ? blockMutator : null;
        this._args = args;
    }
    init(block) {
        this._block = block;
        this.defineBlock();
        this.block.setOnChange(function (event) {
            this.blockInstance.onChange(event);
        });
    }
    onChange(changeEvent) {
        // nothing to do
    }
    toXML() {
        return `<block type="${this.type}" disabled="${this.disabled}"></block>`;
    }
    toDartCode(block) {
        return 'Not implemented';
    }
    toJavaScriptCode(block) {
        return 'Not implemented';
    }
    toLuaCode(block) {
        return 'Not implemented';
    }
    toPHPCode(block) {
        return 'Not implemented';
    }
    toPythonCode(block) {
        return 'Not implemented';
    }
    get block() {
        return this._block;
    }
    set block(block) {
        this._block = block;
    }
    get blockMutator() {
        return this._blockMutator;
    }
    set blockMutator(mutator) {
        this._blockMutator = mutator;
    }
    get args() {
        return this._args;
    }
    set args(args) {
        this._args = args;
    }
}

class XmlBlock extends Block {
    constructor(type, shadow = false) {
        super(type);
        this._values = [];
        this._shadow = shadow;
    }
    get values() {
        return this._values;
    }
    set values(value) {
        this._values = value;
    }
    get field() {
        return this._field;
    }
    set field(value) {
        this._field = value;
    }
    get mutation() {
        return this._mutation;
    }
    set mutation(mutation) {
        this._mutation = mutation;
    }
    toXML() {
        const tagName = this._shadow ? 'shadow' : 'block';
        let xml = `<${tagName} type="${this.type}" disabled="${this.disabled}">`;
        for (const value of this.values) {
            xml += value.toXML();
        }
        xml += this.field ? this.field.toXML() : '';
        if (this._mutation) {
            xml += this._mutation.toXML();
        }
        xml += `</${tagName}>`;
        return xml;
    }
}
class Value {
    constructor(name, block) {
        this._name = name;
        this._block = block;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get block() {
        return this._block;
    }
    set block(value) {
        this._block = value;
    }
    toXML() {
        return `<value name="${this.name}">` + this.block.toXML() + '</value>';
    }
}
class Field {
    constructor(name, value) {
        this._name = name;
        this._value = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
    }
    toXML() {
        return `<field name="${this.name}">` + this.value + '</field>';
    }
}
class Mutation {
    constructor(name, value) {
        this._name = name;
        this._value = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
    }
    toXML() {
        return '<mutation ' + this.name + ' = "' + this.value + '"></mutation>';
    }
}

class Category {
    constructor(name, colour, nodes, custom, style, cssClass, toolboxItemId, hidden) {
        this._name = name;
        this._nodes = nodes ? nodes : [];
        this._colour = colour;
        this._custom = custom;
        this._style = style;
        this._cssClass = cssClass;
        this._toolboxItemId = toolboxItemId ? toolboxItemId : UUID.UUID();
        this._hidden = hidden;
    }
    get nodes() {
        return this._nodes;
    }
    set nodes(nodes) {
        this._nodes = nodes;
    }
    get colour() {
        return this._colour;
    }
    set colour(value) {
        this._colour = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get custom() {
        return this._custom;
    }
    set custom(value) {
        this._custom = value;
    }
    get style() {
        return this._style;
    }
    set style(value) {
        this._style = value;
    }
    get cssClass() {
        return this._cssClass;
    }
    set cssClass(value) {
        this._cssClass = value;
    }
    get toolboxItemId() {
        return this._toolboxItemId;
    }
    set toolboxItemId(value) {
        this._toolboxItemId = value;
    }
    get hidden() {
        return this._hidden;
    }
    set hidden(value) {
        this._hidden = value;
    }
    toXML() {
        let xml = `<category expanded="false" name="${this.name}"`;
        if (this.toolboxItemId) {
            xml += ` toolboxitemid="${this.toolboxItemId}"`;
        }
        if (!this.style) {
            xml += ` colour="${this.colour}"`;
        }
        else {
            xml += ` categorystyle="${this.style}"`;
        }
        if (this.hidden) {
            xml += ' hidden="true"';
        }
        xml += this.cssClass ? ` categoryclass="${this.cssClass}"` : '';
        xml += this.custom ? ` custom="${this.custom}">` : '>';
        for (const element of this.nodes) {
            xml += element.toXML();
        }
        xml += '</category>';
        return xml;
    }
}
const LOGIC_CATEGORY = new Category('Logic', '%{BKY_LOGIC_HUE}', [
    new XmlBlock('controls_if'),
    new XmlBlock('logic_compare'),
    new XmlBlock('logic_operation'),
    new XmlBlock('logic_negate'),
    new XmlBlock('logic_boolean'),
    new XmlBlock('logic_null'),
    new XmlBlock('logic_ternary'),
]);
const LOOP_CATEGORY = new Category('Loops', '%{BKY_LOOPS_HUE}', [
    new XmlBlock('controls_repeat_ext'),
    new XmlBlock('controls_whileUntil'),
    new XmlBlock('controls_for'),
    new XmlBlock('controls_forEach'),
    new XmlBlock('controls_flow_statements')
]);
const MATH_CATEGORY = new Category('Math', '%{BKY_MATH_HUE}', [
    new XmlBlock('math_number'),
    new XmlBlock('math_arithmetic'),
    new XmlBlock('math_single'),
    new XmlBlock('math_trig'),
    new XmlBlock('math_constant'),
    new XmlBlock('math_number_property'),
    new XmlBlock('math_round'),
    new XmlBlock('math_on_list'),
    new XmlBlock('math_modulo'),
    new XmlBlock('math_constrain'),
    new XmlBlock('math_random_int'),
    new XmlBlock('math_random_float'),
    new XmlBlock('math_atan2')
]);
const TEXT_CATEGORY = new Category('Text', '%{BKY_TEXTS_HUE}', [
    new XmlBlock('text'),
    new XmlBlock('text_join'),
    new XmlBlock('text_append'),
    new XmlBlock('text_length'),
    new XmlBlock('text_count'),
    new XmlBlock('text_isEmpty'),
    new XmlBlock('text_indexOf'),
    new XmlBlock('text_charAt'),
    new XmlBlock('text_getSubstring'),
    new XmlBlock('text_changeCase'),
    new XmlBlock('text_multiline'),
    new XmlBlock('text_replace'),
    new XmlBlock('text_reverse'),
    new XmlBlock('text_trim'),
    new XmlBlock('text_print'),
    new XmlBlock('text_prompt'),
    new XmlBlock('text_prompt_ext')
]);
const LISTS_CATEGORY = new Category('Lists', '%{BKY_LISTS_HUE}', [
    new XmlBlock('lists_create_with'),
    new XmlBlock('lists_create_empty'),
    new XmlBlock('lists_repeat'),
    new XmlBlock('lists_reverse'),
    new XmlBlock('lists_length'),
    new XmlBlock('lists_isEmpty'),
    new XmlBlock('lists_indexOf'),
    new XmlBlock('lists_getIndex'),
    new XmlBlock('lists_setIndex'),
    new XmlBlock('lists_getSublist'),
    new XmlBlock('lists_split'),
    new XmlBlock('lists_sort'),
]);
const COLOUR_CATEGORY = new Category('Colours', '%{BKY_COLOUR_HUE}', [
    new XmlBlock('colour_picker'),
    new XmlBlock('colour_random'),
    new XmlBlock('colour_rgb'),
    new XmlBlock('colour_blend')
]);
const VARIABLES_CATEGORY = new Category('Variables', '%{BKY_VARIABLES_HUE}', [], 'VARIABLE');
const FUNCTIONS_CATEGORY = new Category('Functions', '%{BKY_PROCEDURES_HUE}', [], 'PROCEDURE');

class Button {
    constructor(text, callbackKey) {
        this.kind = 'BUTTON';
        this._text = text;
        this._callbackKey = callbackKey;
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
    }
    get callbackKey() {
        return this._callbackKey;
    }
    set callbackKey(value) {
        this._callbackKey = value;
    }
    toXML() {
        return `<button text="${this.text}" callbackKey="${this.callbackKey}"></button>`;
    }
}

class Label {
    constructor(text, _webClass) {
        this.kind = 'LABEL';
        this._text = text;
        this._webClass = _webClass;
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
    }
    get webClass() {
        return this._webClass;
    }
    set webClass(value) {
        this._webClass = value;
    }
    toXML() {
        return `<label text="${this.text}" web-class="${this.webClass}"></label>`;
    }
}

class Separator {
    constructor() {
        this.kind = 'SEP';
    }
    toXML() {
        return '<sep></sep>';
    }
}

class Theme {
    constructor(name, blockStyles, categoryStyles, componentStyle) {
        this.name = name;
        this.blockStyles = blockStyles;
        this.categoryStyles = categoryStyles;
        this.componentStyle = componentStyle;
    }
    createBlocklyTheme() {
        return new Blockly.Theme(this.name, this.blockStyles, this.categoryStyles, this.componentStyle);
    }
}
class BlockStyle {
}

class BlockMutator {
    constructor(name, blockList = null) {
        this._name = name;
        this._blockList = blockList;
    }
    /**
     * @deprecated Use saveExtraState instead
     * https://developers.google.com/blockly/guides/create-custom-blocks/extensions#saveextrastate_and_loadextra
     */
    mutationToDom(block) {
    }
    /**
     * @deprecated Use loadExtraState instead
     * https://developers.google.com/blockly/guides/create-custom-blocks/extensions#saveextrastate_and_loadextrastate
     */
    domToMutation(block, xmlElement) {
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get blockList() {
        return this._blockList;
    }
    set blockList(value) {
        this._blockList = value;
    }
}

class NgxBlocklyToolbox extends Blockly.Toolbox {
    constructor(workspace) {
        super(workspace);
        this.SEARCH_CATEGORY = 'SEARCH_CATEGORY';
        this.SEARCH_PLACEHOLDER = 'SEARCH_PLACEHOLDER';
        this._SEARCHBAR_CLASS = 'searchbar';
        this._TOOLBAR_CLASS = 'toolbar';
        this._categoryId = UUID.UUID();
        this._categoryExpandedCache = new Map();
        workspace.addChangeListener(this._onWorkspaceChange.bind(this));
    }
    init() {
        super.init();
        this._initSearchbar();
    }
    render(parsedToolboxDef) {
        if (parsedToolboxDef.contents.length === 0 || parsedToolboxDef.contents[0].toolboxitemid !== this._categoryId) {
            const name = Blockly.Msg[this.SEARCH_CATEGORY] ? Blockly.Msg[this.SEARCH_CATEGORY] : 'Search';
            const xmlDef = '<xml>' +
                '<category colour="#ccc" expanded="false" name="' + name + '" hidden="true" toolboxitemid="' + this._categoryId + '"></category>' +
                '</xml>';
            const jsonDef = Blockly.utils.toolbox.convertToolboxDefToJson(xmlDef);
            parsedToolboxDef.contents = [jsonDef.contents[0]].concat(parsedToolboxDef.contents);
        }
        super.render(parsedToolboxDef);
        this._restoreExpandedState();
    }
    clearSearch() {
        this._clearSearchResult();
        if (this._input) {
            this._input.value = '';
        }
    }
    toXML() {
        let xml = '<xml id="toolbox" style="display: none">';
        if (this._nodes) {
            for (const node of this._nodes) {
                xml += node.toXML();
            }
        }
        xml += '</xml>';
        return xml;
    }
    get nodes() {
        return this._nodes;
    }
    set nodes(nodes) {
        this._nodes = nodes;
    }
    _initSearchbar() {
        this._input = document.createElement('input');
        this._input.placeholder = Blockly.Msg[this.SEARCH_PLACEHOLDER] ? Blockly.Msg[this.SEARCH_PLACEHOLDER] : 'search';
        this._input.className = this._SEARCHBAR_CLASS;
        this._input.size = 1;
        this._input.addEventListener('keyup', this._search.bind(this));
        const element = this.HtmlDiv.firstChild;
        element.classList.add(this._TOOLBAR_CLASS);
        this.HtmlDiv.insertBefore(this._input, element);
    }
    _search(event) {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => {
            const searchKey = event.target.value.trim();
            if (searchKey.length > 0) {
                const result = this._recursiveSearch(searchKey, this.toolboxDef_);
                if (result.length > 0) {
                    const category = this.getToolboxItemById(this._categoryId);
                    category.updateFlyoutContents(result);
                    category.show();
                    this.setSelectedItem(category);
                }
                else {
                    this._clearSearchResult();
                }
            }
            else {
                this._clearSearchResult();
            }
        }, 100);
    }
    _recursiveSearch(searchKey, child) {
        let blockDefs = [];
        if (child.contents && Array.isArray(child.contents)) {
            if (child.toolboxitemid && child.toolboxitemid === this._categoryId) {
                return blockDefs;
            }
            for (let i = 0; i < child.contents.length; i++) {
                if (typeof (child.contents[i]) === 'object' && child.contents[i].kind) {
                    if (child.contents[i].kind === 'BLOCK' && child.contents[i].type) {
                        const type = child.contents[i].type;
                        if (this._compare(searchKey, type)) {
                            blockDefs.push(child.contents[i]);
                        }
                        else {
                            const workspace = new Blockly.Workspace();
                            const searchBlock = workspace.newBlock(type);
                            if (this._compare(searchKey, searchBlock.tooltip.toString())) {
                                blockDefs.push(child.contents[i]);
                            }
                            workspace.dispose();
                        }
                    }
                    else if (child.contents[i].kind === 'CATEGORY') {
                        const result = this._recursiveSearch(searchKey, child.contents[i]);
                        blockDefs = [...blockDefs, ...result];
                    }
                }
            }
        }
        return blockDefs;
    }
    _clearSearchResult() {
        const flyout = this.workspace_.getFlyout();
        if (flyout) {
            flyout.hide();
        }
        const category = this.getToolboxItemById(this._categoryId);
        if (category) {
            category.hide();
        }
    }
    _storeExpandedState() {
        this.getToolboxItems().forEach(item => {
            if (item.getId() !== this._categoryId) {
                const collapsibleItem = item;
                if (typeof collapsibleItem.isExpanded === 'function') {
                    this._categoryExpandedCache.set(collapsibleItem.getId(), collapsibleItem.isExpanded());
                }
            }
        });
    }
    _restoreExpandedState() {
        this._categoryExpandedCache.forEach((expanded, id) => {
            const collapsibleItem = this.getToolboxItemById(id);
            if (collapsibleItem && typeof collapsibleItem.isExpanded === 'function') {
                this._categoryExpandedCache.set(collapsibleItem.getId(), collapsibleItem.isExpanded());
            }
        });
    }
    _onWorkspaceChange(event) {
        if (event.type === Blockly.Events.TOOLBOX_ITEM_SELECT) {
            this._storeExpandedState();
        }
    }
    _compare(str1, str2) {
        if (typeof str1 === 'string' && typeof str2 === 'string') {
            str1 = this._prepareString(str1);
            str2 = this._prepareString(str2);
            if (str1.length > 0 && str2.length > 0) {
                const array1 = str1.split('_');
                const array2 = str2.split('_');
                for (let i1 = 0; i1 < array1.length; i1++) {
                    for (let i2 = 0; i2 < array2.length; i2++) {
                        if (array2[i2].startsWith(array1[i1])) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    _prepareString(str) {
        str = this._breakUpCamelCase(str);
        str = str.toLowerCase().trim();
        return this._replaceWhitespaceWithUnderscore(str);
    }
    _breakUpCamelCase(str) {
        return str.replace(/([A-Z])/g, ' $1');
    }
    _replaceWhitespaceWithUnderscore(str) {
        return str.replace(/\s+/g, '_');
    }
}

class NgxBlocklyModule {
}
NgxBlocklyModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NgxBlocklyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgxBlocklyModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.12", ngImport: i0, type: NgxBlocklyModule, declarations: [NgxBlocklyComponent], exports: [NgxBlocklyComponent] });
NgxBlocklyModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NgxBlocklyModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NgxBlocklyModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgxBlocklyComponent],
                    imports: [],
                    exports: [NgxBlocklyComponent],
                    providers: [],
                    schemas: [NO_ERRORS_SCHEMA]
                }]
        }] });
// Still needed?
// Blockly.ToolboxCategory.prototype.parseContents_ = function (categoryDef) {
//     const contents = categoryDef['contents'];
//     if (categoryDef['custom']) {
//         this.flyoutItems_ = categoryDef['custom'];
//     } else if (contents) {
//         for (let i = 0, itemDef; (itemDef = contents[i]); i++) {
//             const flyoutItem = (itemDef);
//             this.flyoutItems_.push(flyoutItem);
//         }
//     }
//     if (categoryDef['categoryclass']) {
//         this.cssConfig_.row += ' ' + categoryDef['categoryclass'];
//     }
// };
Blockly.CollapsibleToolboxCategory.prototype.parseContents_ = function (categoryDef) {
    const contents = categoryDef['contents'];
    let prevIsFlyoutItem = true;
    if (categoryDef['custom']) {
        this.flyoutItems_ = categoryDef['custom'];
    }
    else if (contents) {
        for (let i = 0, itemDef; (itemDef = contents[i]); i++) {
            // Separators can exist as either a flyout item or a toolbox item so
            // decide where it goes based on the type of the previous item.
            if (!Blockly.registry.hasItem(Blockly.registry.Type.TOOLBOX_ITEM, itemDef['kind']) ||
                (itemDef['kind'].toLowerCase() === Blockly.ToolboxSeparator.registrationName &&
                    prevIsFlyoutItem)) {
                const flyoutItem = (itemDef);
                this.flyoutItems_.push(flyoutItem);
                prevIsFlyoutItem = true;
            }
            else {
                this.createToolboxItem_(itemDef);
                prevIsFlyoutItem = false;
            }
        }
    }
    if (categoryDef['categoryclass']) {
        this.cssConfig_.row += ' ' + categoryDef['categoryclass'];
    }
};

/*
 * Public API Surface of ngx-blockly
 */
Blockly.setLocale(EN);

/**
 * Generated bundle index. Do not edit.
 */

export { Block, BlockMutator, BlockStyle, Button, COLOUR_CATEGORY, Category, CustomBlock, FUNCTIONS_CATEGORY, Field, LISTS_CATEGORY, LOGIC_CATEGORY, LOOP_CATEGORY, Label, MATH_CATEGORY, Mutation, NgxBlocklyComponent, NgxBlocklyGenerator, NgxBlocklyGeneratorConfig, NgxBlocklyModule, NgxBlocklyToolbox, Separator, TEXT_CATEGORY, Theme, VARIABLES_CATEGORY, Value, XmlBlock };
//# sourceMappingURL=ngx-blockly.mjs.map
