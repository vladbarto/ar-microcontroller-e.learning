import { AfterViewInit, ElementRef, EventEmitter, OnChanges, OnDestroy, OnInit, SimpleChange } from '@angular/core';
import { NgxBlocklyConfig } from './ngx-blockly.config';
import { CustomBlock } from './models/custom-block';
import * as Blockly from 'blockly/core';
import * as i0 from "@angular/core";
export declare class NgxBlocklyComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {
    config: NgxBlocklyConfig;
    customBlocks: CustomBlock[];
    readOnly: boolean;
    workspaceCreate: EventEmitter<Blockly.WorkspaceSvg>;
    workspaceChange: EventEmitter<Blockly.Events.AbstractEventJson>;
    toolboxChange: EventEmitter<any>;
    dartCode: EventEmitter<string>;
    javascriptCode: EventEmitter<string>;
    luaCode: EventEmitter<string>;
    phpCode: EventEmitter<string>;
    pythonCode: EventEmitter<string>;
    xmlCode: EventEmitter<string>;
    primaryContainer: ElementRef;
    secondaryContainer: ElementRef;
    workspace: Blockly.WorkspaceSvg;
    private _secondaryWorkspace;
    private _resizeTimeout;
    private _finishedLoading;
    static initCustomBlocks(blocks: CustomBlock[]): void;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnChanges(changes: {
        [propKey: string]: SimpleChange;
    }): void;
    ngOnDestroy(): void;
    onResize(event: any): void;
    /**
     * Generate code for all blocks in the workspace to the specified output.
     * @param workspaceId Workspace to generate code from.
     */
    workspaceToCode(workspaceId: string): void;
    /**
     * Converts a DOM structure into properly indented text.
     * @return Text representation.
     */
    toXml(): string;
    /**
     * Clear the given workspace then decode an XML DOM and
     * create blocks on the workspace.
     * @param xml XML DOM..
     */
    fromXml(xml: string): void;
    /**
     * Decode an XML DOM and create blocks on the workspace. Position the new
     * blocks immediately below prior blocks, aligned by their starting edge.
     * @param xml The XML DOM.
     */
    appendFromXml(xml: string): void;
    /**
     * Dispose of all blocks in workspace, with an optimization to prevent resizes.
     */
    clear(): void;
    /**
     * Clear the undo/redo stacks.
     */
    clearUndo(): void;
    /**
     * Clear the reference to the current gesture.
     */
    clearGesture(): void;
    /**
     * Clear search input and result set.
     */
    clearSearch(): void;
    /**
     * Size the workspace when the contents change. This also updates
     * scrollbars accordingly.
     */
    resize(): void;
    setReadonly(readOnly: boolean): void;
    highlightBlock(blockId: string): void;
    private _onWorkspaceChange;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxBlocklyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NgxBlocklyComponent, "ngx-blockly", never, { "config": "config"; "customBlocks": "customBlocks"; "readOnly": "readOnly"; }, { "workspaceCreate": "workspaceCreate"; "workspaceChange": "workspaceChange"; "toolboxChange": "toolboxChange"; "dartCode": "dartCode"; "javascriptCode": "javascriptCode"; "luaCode": "luaCode"; "phpCode": "phpCode"; "pythonCode": "pythonCode"; "xmlCode": "xmlCode"; }, never, never, false>;
}
